@file:JvmName("GastManager")

package org.godotengine.plugin.gast

import android.app.Activity
import android.os.Handler
import android.os.Looper
import android.util.Log
import android.widget.FrameLayout
import org.godotengine.godot.Godot
import org.godotengine.godot.plugin.GodotPlugin
import org.godotengine.plugin.gast.input.InputDispatcher
import org.godotengine.plugin.gast.input.GastInputListener
import org.godotengine.plugin.gast.input.InputType
import java.util.concurrent.ConcurrentLinkedQueue
import javax.microedition.khronos.opengles.GL10

/**
 * GAST core plugin.
 *
 * Provides the functionality for rendering, interacting and manipulating content generated by the
 * Android system onto Godot textures.
 */
class GastManager(godot: Godot) : GodotPlugin(godot) {

    init {
        System.loadLibrary("gast")
    }

    private val gastRenderListeners = ConcurrentLinkedQueue<GastRenderListener>()
    private val gastInputListeners = ConcurrentLinkedQueue<GastInputListener>()

    private val mainThreadHandler = Handler(Looper.getMainLooper())

    /**
     * Root parent for all GAST views.
     */
    val rootView = FrameLayout(godot)

    companion object {
        private val TAG = GastManager::class.java.simpleName
        private const val INVALID_SURFACE_INDEX = -1
    }

    override fun onGodotMainLoopStarted() {
        Log.d(TAG, "Initializing $pluginName manager")
        initialize()
    }

    override fun onMainCreateView(activity: Activity) = rootView

    override fun onMainDestroy() {
        Log.d(TAG, "Shutting down $pluginName manager")
        runOnRenderThread { shutdown() }
    }

    override fun onGLDrawFrame(gl: GL10) {
        for (listener in gastRenderListeners) {
            listener.onRenderDrawFrame()
        }
    }

    override fun getPluginMethods(): MutableList<String> = emptyList<String>().toMutableList()

    override fun getPluginName() = "gast-core"

    override fun getPluginGDNativeLibrariesPaths() = setOf("godot/plugin/v1/gast/gastlib.gdnlib")

    /**
     * Register a [GastRenderListener] instance to be notified of rendering related events.
     */
    fun registerGastRenderListener(listener: GastRenderListener) {
        gastRenderListeners += listener
    }

    /**
     * Unregister a previously registered [GastRenderListener] instance.
     */
    fun unregisterGastRenderListener(listener: GastRenderListener) {
        gastRenderListeners -= listener
    }

    /**
     * Register a [GastInputListener] instance to be notified of input related events.
     */
    fun registerGastInputListener(listener: GastInputListener) {
        gastInputListeners += listener
    }

    /**
     * Unregister a previously registered [GastInputListener] instance.
     */
    fun unregisterGastInputListener(listener: GastInputListener) {
        gastInputListeners -= listener
    }

    /**
     * Get the texture id for the Gast node with the given path.
     * @param nodePath - Path to the Gast node whose texture id to retrieve
     */
    @JvmOverloads
    external fun getExternalTextureId(
        nodePath: String,
        surfaceIndex: Int = INVALID_SURFACE_INDEX
    ): Int

    /**
     * Create a Gast node with the given parent node and set it up.
     * @param parentNodePath - Path to the parent for the Gast node that will be created. The parent node must exist
     * @param emptyParent - If true, remove the children of the parent (if any) prior to inserting the Gast node
     * @return The node path to the newly created Gast node
     */
    @JvmOverloads
    external fun acquireAndBindGastNode(parentNodePath: String, emptyParent: Boolean = false): String

    /**
     * Unbind and release the Gast node with the given node path. This is the counterpart to [GastManager.acquireAndBindGastNode]
     * @param nodePath - Path to the Gast node that should be released
     */
    external fun unbindAndReleaseGastNode(nodePath: String)

    /**
     * Reparent the given Gast node to the specified parent node.
     * @param nodePath - Path to the Gast node
     * @param newParentNodePath - Path to the new parent
     * @param emptyParent - If true, remove the children of the parent (if any) prior to inserting the Gast node
     * @return The new path for the reparented Gast node
     */
    @JvmOverloads
    external fun updateGastNodeParent(nodePath: String, newParentNodePath: String, emptyParent: Boolean = false): String

    /**
     * Update the visibility of the given Gast node.
     * @param nodePath - Path to the Gast node
     * @param shouldDuplicateParentVisibility - Whether the node should match its parent's visibility
     * @param visible - True to make the node visible, false otherwise
     */
    external fun updateGastNodeVisibility(
        nodePath: String,
        shouldDuplicateParentVisibility: Boolean,
        visible: Boolean
    )

    /**
     * Update the collision flag for the Gast node.
     * @param nodePath - Path to the Gast node
     * @param collidable - True to enable collision, false to disable.
     */
    external fun setGastNodeCollidable(nodePath: String, collidable: Boolean)

    /**
     * Return true if collision is enabled for the node.
     */
    external fun isGastNodeCollidable(nodePath: String): Boolean

    /**
     * Update the size of the Gast node.
     */
    external fun updateGastNodeSize(nodePath: String, width: Float, height: Float)

    /**
     * Translate the Gast node relative to its parent.
     */
    external fun updateGastNodeLocalTranslation(
        nodePath: String,
        xTranslation: Float,
        yTranslation: Float,
        zTranslation: Float
    )

    /**
     * Scale the Gast node relative to its parent.
     */
    external fun updateGastNodeLocalScale(nodePath: String, xScale: Float, yScale: Float)

    /**
     * Rotate the Gast node relative to its parent.
     */
    external fun updateGastNodeLocalRotation(
        nodePath: String,
        xRotation: Float,
        yRotation: Float,
        zRotation: Float
    )

    private fun dispatchInputEvent(
        inputType: InputType,
        nodePath: String,
        pointerId: String,
        vararg inputData: Float
    ) {
        val dispatcher = InputDispatcher.acquireInputDispatcher(
            gastInputListeners,
            inputType,
            nodePath,
            pointerId,
            inputData
        )
        mainThreadHandler.post(dispatcher)
    }

    private external fun initialize()

    private external fun shutdown()

    private fun onRenderInputHover(
        nodePath: String,
        pointerId: String,
        xPercent: Float,
        yPercent: Float
    ) {
        dispatchInputEvent(InputType.HOVER, nodePath, pointerId, xPercent, yPercent)
    }

    private fun onRenderInputPress(
        nodePath: String,
        pointerId: String,
        xPercent: Float,
        yPercent: Float
    ) {
        dispatchInputEvent(InputType.PRESS, nodePath, pointerId, xPercent, yPercent)
    }

    private fun onRenderInputRelease(
        nodePath: String,
        pointerId: String,
        xPercent: Float,
        yPercent: Float
    ) {
        dispatchInputEvent(InputType.RELEASE, nodePath, pointerId, xPercent, yPercent)
    }

    private fun onRenderInputScroll(
        nodePath: String,
        pointerId: String,
        xPercent: Float,
        yPercent: Float,
        horizontalDelta: Float,
        verticalDelta: Float
    ) {
        dispatchInputEvent(
            InputType.SCROLL,
            nodePath,
            pointerId,
            xPercent,
            yPercent,
            horizontalDelta,
            verticalDelta
        )
    }

}
